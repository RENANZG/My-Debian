<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SaltStack Automation in Qubes OS</title>
<style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      padding: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    h1, h3 {
      color: #2c3e50;
    }
    code {
      background-color: #eaeaea;
      padding: 2px 4px;
      border-radius: 4px;
    }
    pre {
      background-color: #f4f4f4;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow-x: auto;
    }
    ul {
      margin-left: 20px;
    }
</style>
</head>
<body>

  <h2>SaltStack Automation in Qubes OS</h2>

  <h3>Overview</h3>

  <p><strong>SaltStack</strong> is a powerful, flexible automation framework designed for managing system configurations and automating tasks across distributed systems. Integrated into <strong>Qubes OS</strong>, SaltStack helps automate the management of qubes (virtual machines) and the underlying infrastructure, streamlining processes for system configuration, software deployment, and updates.</p>

  <p>SaltStack uses a master-minion model where the <strong>Salt Master</strong> (server) controls and communicates with the <strong>Salt Minions</strong> (clients), making it ideal for distributed environments like Qubes OS, where multiple isolated qubes need coordinated management.</p>

  <h3>Key Concepts in SaltStack Automation:</h3>

  <ul>
  <li><strong>States:</strong>
    <p>SaltStack uses <strong>states</strong> to define the desired configuration of systems. States are written in <strong>YAML</strong>, with optional <strong>Jinja</strong> templating to introduce dynamic content and logic. States ensure that systems are maintained in a specific state (e.g., ensuring a package is installed, a service is running, or a file is present).</p>
    <p><strong>YAML</strong>: Simple and human-readable, YAML is the default language for defining states.</p>
    <p><strong>Jinja</strong>: This templating engine allows for powerful, dynamic configurations by enabling conditional logic, loops, and variable interpolation in Salt states, reducing redundancy and increasing flexibility.</p>
  </li>
  <li><strong>Pillars:</strong>
    <p>Salt’s <strong>pillar</strong> system provides a way to securely distribute data to minions. This is particularly useful for managing sensitive information such as passwords, API keys, or cryptographic secrets. Data is stored on the <strong>Salt Master</strong> and selectively made available to specific minions. Pillars ensure secure, isolated access to sensitive data without exposing it in configuration files.</p>
    <p><strong>Encryption:</strong> Pillar data can be encrypted, ensuring that secrets remain protected even if transmitted across less secure channels.</p>
  </li>
  <li><strong>Modules:</strong>
    <p><strong>Salt modules</strong> are pre-built tools that perform specific tasks (e.g., installing packages, managing services). Minions can access various modules based on their configuration.</p>
    <p><strong>Returners:</strong> A specialized type of module that collects and sends data generated by jobs to external systems like databases, log aggregators, or monitoring systems.</p>
  </li>
  <li><strong>Grains:</strong>
    <p><strong>Grains</strong> are pieces of metadata collected by the Salt Minion about the system it is running on. Information such as the operating system, IP address, memory, or architecture is gathered automatically when the minion starts. Grains enable Salt to make decisions about which configurations should be applied based on the system's properties, allowing for tailored automation based on system characteristics.</p>
    <p><strong>Targeting Minions:</strong> Grains can be used in conjunction with targeting to ensure that commands are sent only to the relevant systems.</p>
  </li>
  <li><strong>Formulas:</strong>
  <p><strong>Salt formulas</strong> are collections of Salt states, typically organized into reusable packages that automate the setup and configuration of complex applications or services. A formula usually includes multiple states, configurations, and files necessary to deploy and manage a specific software stack or service.</p>
  <p><strong>Reusable and Modular:</strong> Formulas provide a modular approach to configuration management, allowing users to easily deploy and reconfigure applications across multiple systems without duplicating efforts.</p>
  <p><strong>Community-Driven:</strong> The SaltStack community maintains a rich library of formulas on GitHub, where users can share, improve, and contribute configurations for common applications. This collaborative environment helps streamline deployment processes and makes it easier to adopt best practices across diverse environments.</p>
  </li>
  </li>
  </ul>

  <h3>Important SaltStack File Extensions</h3>

  <p>SaltStack utilizes various file extensions to manage configurations, sensitive data, and custom functionality. Below are the most important extensions used in SaltStack:</p>

  <ul>
  <li><strong>.sls</strong> – <em>Salt State Files</em>: The most important file type for configuration management. These files define the desired state of systems (e.g., installed packages, running services, etc.).</li>
  <pre><code>example.sls</code></pre>
  <li><strong>.top</strong> – <em>Top File</em>: The top file (usually named <code>top.sls</code>) maps Salt states to specific minions. It defines which states should be applied to which minions or groups of minions.</li>
  <pre><code>top.sls</code></pre>
  <li><strong>.pillar</strong> – <em>Pillar Files</em>: Files that store sensitive and system-specific configuration data, often used to store things like passwords, API keys, and other confidential information.</li>
  <pre><code>example.pillar</code></pre>
  <li><strong>.j2 or .jinja</strong> – <em>Jinja2 Templates</em>: Jinja2 templates are used within SaltStack for dynamic content generation, allowing for flexibility and customization of configurations by embedding logic into configuration files.</li>
  <pre><code>template.j2</code></pre>
  <li><strong>.conf</strong> – <em>Configuration Files</em>: Standard system configuration files (e.g., for services like Nginx or Apache) that SaltStack manages to ensure they are configured correctly across systems.</li>
  <pre><code>nginx.conf</code></pre>
  <li><strong>.py</strong> – <em>Python Files</em>: Custom Python modules are used to extend SaltStack’s functionality, allowing you to write custom execution modules, returners, or states.</li>
  <pre><code>custom_module.py</code></pre>
  </ul>

  <h3>SaltStack State Functions</h3>

  <p>SaltStack provides several commands for applying states to minions. These functions allow for flexible and powerful configuration management in SaltStack, enabling you to apply configurations across many systems efficiently. These functions help manage the application of those configurations:</p>

  <ul>
    <li><strong>state.sls</strong>: Applies a specific state file to a minion. This is useful when you want to apply one or more states explicitly without using the top file.</li>
    <pre><code>sudo salt 'minion_id' state.sls my_state</code></pre>
    <li><strong>state.top</strong>: Refers to the <code>top.sls</code> file, which defines which states apply to which minions. It's not run directly, but is used in conjunction with <code>state.highstate</code>.</li>
    <li><strong>state.highstate</strong>: Applies all states defined in the <code>top.sls</code> file for a minion. This is typically used to apply all configurations specified in the top file.</li>
    <pre><code>sudo salt 'minion_id' state.highstate</code></pre>
    <li><strong>state.apply</strong>: Applies a specific state or set of states to a minion. Use this to apply a configuration directly from a state file.</li>
    <pre><code>sudo salt 'minion_id' state.apply my_state.sls</code></pre>
  </ul>

  <h3>Base Salt Configuration</h3>

  <p>The base Salt configuration directory in <code>dom0</code> is:</p>

  <pre><code>/srv/salt/qubes/README.rst</code></pre>

  <p>To initialize the user Salt configuration directories, run the following command in <code>dom0</code>:</p>

  <pre><code>sudo qubesctl state.sls qubes.user-dirs</code></pre>

  <p>This command creates the following directories:</p>
  
  <ul>
    <li><code>/srv/user_salt/</code>: Stores user-defined Salt states.</li>
    <li><code>/srv/user_formulas/</code>: Stores custom Salt formulas.</li>
    <li><code>/srv/user_pillar/</code>: Stores pillar data for configurations.</li>
  </ul>

  <p>Additionally, a top file is generated at:</p>

  <pre><code>/srv/user_salt/top.sls</code></pre>

<h3>Example: Adding a Custom Policy in Qubes OS for Work AppVM</h3>

<p>To create a new Salt policy that installs applications in a work AppVM, follow these steps:</p>

<ol>
  <li><strong>Create a directory for your policy:</strong> This will be the location where the custom states will reside.</li>
  <pre><code>mkdir -p /srv/user_salt/my_policy</code></pre>
  
  <li><strong>Create a new Salt state file:</strong> For example, create a state file named <code>install_tools.sls</code> to install applications like <code>git</code>, <code>curl</code>, and <code>vim</code> in the AppVM.</li>
  <pre><code>
  # /srv/user_salt/my_policy/install_tools.sls
  install-tools:
    pkg.installed:
      - pkgs:
        - git
        - curl
        - vim
  </code></pre>
  
  <li><strong>Add the new policy to the <code>top.sls</code> file:</strong> The <code>top.sls</code> file tells SaltStack which states to apply to which minions. Add the new policy for your work AppVM here.</li>
  <pre><code>
  # /srv/user_salt/top.sls
  base:
    'work*':  # Applies to any AppVM starting with 'work'
      - my_policy.install_tools
  </code></pre>

  <li><strong>Apply the policy:</strong> After setting up the state and top files, you can apply the policy using the following command to install the applications in the targeted work AppVM.</li>
  <pre><code>sudo qubesctl state.apply</code></pre>
  
  <p>After running this command, the specified packages (<code>git</code>, <code>curl</code>, and <code>vim</code>) will be installed in any AppVM with a name that starts with <code>work</code>, such as <code>work-appvm</code>.</p>

  <p><strong>Note:</strong> Replace <code>work*</code> in the <code>top.sls</code> with the actual name that fits your Qubes AppVMs.</p>
</ol>

  <h3>Practical Tips</h3>

  <ul>
    <li>Test new policies in a disposable VM before applying them globally.</li>
    <li>Use descriptive names for your state files and directories.</li>
    <li>Leverage the power of pillars for secure and reusable configurations.</li>
    <li>Use version control (e.g., Git) to manage your Salt states and track changes.</li>
  </ul>

  <h3>References</h3>

  <ul>
    <li><a href="https://www.qubes-os.org/doc/salt/" target="_blank">Qubes OS SaltStack Documentation</a></li>
    <li><a href="https://docs.saltproject.io/" target="_blank">SaltStack Official Documentation</a></li>
    <li><a href="https://forum.qubes-os.org/t/qubes-salt-beginners-guide/20126/40" target="_blank">Qubes Salt Beginner’s Guide - Qubes Community Guides</a></li>
  </ul>

</body>
</html>
